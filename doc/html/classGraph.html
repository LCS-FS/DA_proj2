<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Da Proj 2: Graph&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Da Proj 2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae667eecd89799c645634c0d78a3e98e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae667eecd89799c645634c0d78a3e98e6">printPath</a> (std::map&lt; vector&lt; T &gt;, T &gt; printablePath)</td></tr>
<tr class="separator:ae667eecd89799c645634c0d78a3e98e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7b7465fbfd562e2a469f90a437ab75"><td class="memItemLeft" align="right" valign="top"><a id="a8b7b7465fbfd562e2a469f90a437ab75"></a>
<a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>findVertex</b> (const T &amp;in) const</td></tr>
<tr class="separator:a8b7b7465fbfd562e2a469f90a437ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00be284ea2be3b3d0f0d2e493b70245b"><td class="memItemLeft" align="right" valign="top"><a id="a00be284ea2be3b3d0f0d2e493b70245b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addVertex</b> (const T &amp;in)</td></tr>
<tr class="separator:a00be284ea2be3b3d0f0d2e493b70245b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce9e10080f6f8e882ae52a60bf26192"><td class="memItemLeft" align="right" valign="top"><a id="a8ce9e10080f6f8e882ae52a60bf26192"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (const T &amp;sourc, const T &amp;dest, int d, int c, int w)</td></tr>
<tr class="separator:a8ce9e10080f6f8e882ae52a60bf26192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0853eac15cdf0f06d63f4b8a7820ec71"><td class="memItemLeft" align="right" valign="top"><a id="a0853eac15cdf0f06d63f4b8a7820ec71"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumVertex</b> () const</td></tr>
<tr class="separator:a0853eac15cdf0f06d63f4b8a7820ec71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41624b03fcb6bd29e4df574a1ec58541"><td class="memItemLeft" align="right" valign="top"><a id="a41624b03fcb6bd29e4df574a1ec58541"></a>
std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexSet</b> () const</td></tr>
<tr class="separator:a41624b03fcb6bd29e4df574a1ec58541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3bd0a6762247602143c7ead95fc4bf"><td class="memItemLeft" align="right" valign="top">std::map&lt; vector&lt; int &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9b3bd0a6762247602143c7ead95fc4bf">FindPathGivenGroupSize</a> (T st, T ta, int groupSize)</td></tr>
<tr class="separator:a9b3bd0a6762247602143c7ead95fc4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201f3f5fbf9510184e30712879e33429"><td class="memItemLeft" align="right" valign="top"><a id="a201f3f5fbf9510184e30712879e33429"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberNodes</b> () const</td></tr>
<tr class="separator:a201f3f5fbf9510184e30712879e33429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae512eea4bfdf88516712583a6cb009bd"><td class="memItemLeft" align="right" valign="top"><a id="ae512eea4bfdf88516712583a6cb009bd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberEdges</b> () const</td></tr>
<tr class="separator:ae512eea4bfdf88516712583a6cb009bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2556157dbf5defa8a30cdc0b996136"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ada2556157dbf5defa8a30cdc0b996136">firstAlgorithm</a> (T start, T end)</td></tr>
<tr class="separator:ada2556157dbf5defa8a30cdc0b996136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872df230eb39d51ce5bc9b0ca528c7c0"><td class="memItemLeft" align="right" valign="top"><a id="a872df230eb39d51ce5bc9b0ca528c7c0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>heapComp</b> (const <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v1, const <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v2) const</td></tr>
<tr class="separator:a872df230eb39d51ce5bc9b0ca528c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f471fd8b2b6f0b9df1d9dfad44ecbde"><td class="memItemLeft" align="right" valign="top"><a id="a5f471fd8b2b6f0b9df1d9dfad44ecbde"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNumberNodes</b> (int numberNodes)</td></tr>
<tr class="separator:a5f471fd8b2b6f0b9df1d9dfad44ecbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d2221f4ea01d570bcb05455b7413d2"><td class="memItemLeft" align="right" valign="top"><a id="a13d2221f4ea01d570bcb05455b7413d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNumberEdges</b> (int numberEdges)</td></tr>
<tr class="separator:a13d2221f4ea01d570bcb05455b7413d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445a38cf4045797198eae2b818b602de"><td class="memItemLeft" align="right" valign="top"><a id="a445a38cf4045797198eae2b818b602de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dijkstraShortestPath</b> (const T &amp;s)</td></tr>
<tr class="separator:a445a38cf4045797198eae2b818b602de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa033b71894f347b9050e1c547fb48b72"><td class="memItemLeft" align="right" valign="top"><a id="aa033b71894f347b9050e1c547fb48b72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unweightedShortestPath</b> (const T &amp;s)</td></tr>
<tr class="separator:aa033b71894f347b9050e1c547fb48b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6769b79beaa76f78fd9c9209833bef"><td class="memItemLeft" align="right" valign="top"><a id="a1d6769b79beaa76f78fd9c9209833bef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bellmanFordShortestPath</b> (const T &amp;s)</td></tr>
<tr class="separator:a1d6769b79beaa76f78fd9c9209833bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b10f45166faaa19879fca4e73b6f40"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad9b10f45166faaa19879fca4e73b6f40">getPath</a> (const T &amp;origin, const T &amp;dest) const</td></tr>
<tr class="separator:ad9b10f45166faaa19879fca4e73b6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5161f4408bf1ead2b29d19d67fb04ee"><td class="memItemLeft" align="right" valign="top"><a id="ae5161f4408bf1ead2b29d19d67fb04ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>floydWarshallShortestPath</b> ()</td></tr>
<tr class="separator:ae5161f4408bf1ead2b29d19d67fb04ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace531664e93db533d1bcaf532b97348e"><td class="memItemLeft" align="right" valign="top"><a id="ace531664e93db533d1bcaf532b97348e"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getfloydWarshallPath</b> (const T &amp;origin, const T &amp;dest) const</td></tr>
<tr class="separator:ace531664e93db533d1bcaf532b97348e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a8118f05fc1b0ab2e821618e4a90ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a00a8118f05fc1b0ab2e821618e4a90ac">edmondKarpFlux</a> (T st, T ta)</td></tr>
<tr class="separator:a00a8118f05fc1b0ab2e821618e4a90ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa167310b94b212c2c924f4c68038c7e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html">Graph</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa167310b94b212c2c924f4c68038c7e4">residualGrid</a> ()</td></tr>
<tr class="separator:aa167310b94b212c2c924f4c68038c7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c657f3051db9c08b79239622a495b58"><td class="memItemLeft" align="right" valign="top"><a id="a5c657f3051db9c08b79239622a495b58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5c657f3051db9c08b79239622a495b58">zeroFlux</a> ()</td></tr>
<tr class="memdesc:a5c657f3051db9c08b79239622a495b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets flux of every edge on the graph to zero. <br /></td></tr>
<tr class="separator:a5c657f3051db9c08b79239622a495b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b92cb0e86110b54cdb991a2ac4ae4ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a6b92cb0e86110b54cdb991a2ac4ae4ab">increaseGroupSize</a> (T st, T ta, int inc)</td></tr>
<tr class="separator:a6b92cb0e86110b54cdb991a2ac4ae4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a393ee47d9ff160f1656ef71b890d0"><td class="memItemLeft" align="right" valign="top"><a id="a25a393ee47d9ff160f1656ef71b890d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>auxTest2_4</b> ()</td></tr>
<tr class="separator:a25a393ee47d9ff160f1656ef71b890d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08eff19f4f9621ca212a0aea7c9a6cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ab08eff19f4f9621ca212a0aea7c9a6cc">topoSort</a> (T st, std::stack&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;stack)</td></tr>
<tr class="separator:ab08eff19f4f9621ca212a0aea7c9a6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242445b60bd1f6c5ee2fe5cf8dd23633"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a242445b60bd1f6c5ee2fe5cf8dd23633">longestPath</a> (T st, T ta)</td></tr>
<tr class="separator:a242445b60bd1f6c5ee2fe5cf8dd23633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5c29368e4760b0b9a81d4967187775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#afd5c29368e4760b0b9a81d4967187775">printGraph</a> ()</td></tr>
<tr class="separator:afd5c29368e4760b0b9a81d4967187775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2931de4d06954374ee4724b5817133e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2931de4d06954374ee4724b5817133e1">vertexTime</a> (T st, T ta)</td></tr>
<tr class="separator:a2931de4d06954374ee4724b5817133e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb711e6e2ff8c3f476dfeb0025519ab"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acdb711e6e2ff8c3f476dfeb0025519ab">capacityOrEdges</a> (T st, T ta)</td></tr>
<tr class="separator:acdb711e6e2ff8c3f476dfeb0025519ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acdb711e6e2ff8c3f476dfeb0025519ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb711e6e2ff8c3f476dfeb0025519ab">&#9670;&nbsp;</a></span>capacityOrEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; T &gt; &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::capacityOrEdges </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates best paths for a unsplittable group based on capacity and number of nodes If multiple paths aren't better than the others in both capacity and number of nodes, all of them are returned </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of paths as a vector of nodes T </dd></dl>

</div>
</div>
<a id="a00a8118f05fc1b0ab2e821618e4a90ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a8118f05fc1b0ab2e821618e4a90ac">&#9670;&nbsp;</a></span>edmondKarpFlux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::edmondKarpFlux </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Algorithm to calculate the maximum size of a group that can travel separately Based on the Edmond Karp variant of the Ford Fulkerson method for determining maximum flow Sets appropriate flux for each edge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum group size for the graph </dd></dl>

</div>
</div>
<a id="a9b3bd0a6762247602143c7ead95fc4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3bd0a6762247602143c7ead95fc4bf">&#9670;&nbsp;</a></span>FindPathGivenGroupSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; vector&lt; T &gt;, T &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::FindPathGivenGroupSize </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Algorithm to calculate the paths for a splittable group of a given size Based on the Edmond Karp variant of the Ford Fulkerson method for determining maximum flow Sets appropriate flux for each edge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
    <tr><td class="paramname">groupSize</td><td>desired group size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map of the paths the group should take </dd></dl>

</div>
</div>
<a id="ada2556157dbf5defa8a30cdc0b996136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2556157dbf5defa8a30cdc0b996136">&#9670;&nbsp;</a></span>firstAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::firstAlgorithm </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the highest capacity path in the graph Works for unseperable groups Based on the algorithm for higest capacity path in the theory slides </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum capacity, in the highest capacity path in the graph </dd></dl>

</div>
</div>
<a id="ad9b10f45166faaa19879fca4e73b6f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b10f45166faaa19879fca4e73b6f40">&#9670;&nbsp;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getPath </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines path based on destination and origin Steps back from destination's path to previous vertex until it reaches the origin vertex </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>number associated with Origin <a class="el" href="classVertex.html">Vertex</a> </td></tr>
    <tr><td class="paramname">dest</td><td>number associated with Destination <a class="el" href="classVertex.html">Vertex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of numbers associated with Vertexes in path, in order </dd></dl>

</div>
</div>
<a id="a6b92cb0e86110b54cdb991a2ac4ae4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b92cb0e86110b54cdb991a2ac4ae4ab">&#9670;&nbsp;</a></span>increaseGroupSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::increaseGroupSize </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Algorithm to increase group size based on previous paths Based on the Edmond Karp variant of the Ford Fulkerson method for determining maximum flux Sets appropriate flux for each edge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
    <tr><td class="paramname">inc</td><td>amount to increase group size by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>how much the group size was increased by or -1 if it cant be increased by the desired amount </dd></dl>

</div>
</div>
<a id="a242445b60bd1f6c5ee2fe5cf8dd23633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242445b60bd1f6c5ee2fe5cf8dd23633">&#9670;&nbsp;</a></span>longestPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::longestPath </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the longest path, in duration, between 2 nodes Similar to dijkstra's algorithm for shortest distance paths, using topological sort Should be used after a flux setting algorithm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>longest duration between ta and st nodes </dd></dl>

</div>
</div>
<a id="afd5c29368e4760b0b9a81d4967187775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5c29368e4760b0b9a81d4967187775">&#9670;&nbsp;</a></span>printGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::printGraph</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the caracteristics of all edges in the graph Show origin, destination, flux and capacity </p>

</div>
</div>
<a id="ae667eecd89799c645634c0d78a3e98e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae667eecd89799c645634c0d78a3e98e6">&#9670;&nbsp;</a></span>printPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::printPath </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; vector&lt; T &gt;, T &gt;&#160;</td>
          <td class="paramname"><em>printablePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints all the paths and how many people go through each of them </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">printablePath</td><td>a map of paths, as a vector of nodes T, and number of people that can go through them </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa167310b94b212c2c924f4c68038c7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa167310b94b212c2c924f4c68038c7e4">&#9670;&nbsp;</a></span>residualGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html">Graph</a>&lt; T &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::residualGrid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a residual grid graph based on the current graph </p><dl class="section return"><dt>Returns</dt><dd>graph object of the residual grid </dd></dl>

</div>
</div>
<a id="ab08eff19f4f9621ca212a0aea7c9a6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08eff19f4f9621ca212a0aea7c9a6cc">&#9670;&nbsp;</a></span>topoSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::topoSort </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>stack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts nodes on a stack, in topological order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">reference</td><td>to a stack of pointers of nodes, where the nodes will be inserted in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2931de4d06954374ee4724b5817133e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2931de4d06954374ee4724b5817133e1">&#9670;&nbsp;</a></span>vertexTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::vertexTime </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the earliest and latest arrival at every node Prints every node where people must wait for other people and how long they wait for Dijkstra's algorithm is used to compute earliest arrival LongestPath algorithm is used to compute latest arrival </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Graph_8h_source.html">Graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
