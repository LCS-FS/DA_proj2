<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Da Proj 2: Graph&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Da Proj 2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classGraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae667eecd89799c645634c0d78a3e98e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae667eecd89799c645634c0d78a3e98e6">printPath</a> (std::map&lt; vector&lt; T &gt;, T &gt; printablePath)</td></tr>
<tr class="separator:ae667eecd89799c645634c0d78a3e98e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7b7465fbfd562e2a469f90a437ab75"><td class="memItemLeft" align="right" valign="top"><a id="a8b7b7465fbfd562e2a469f90a437ab75" name="a8b7b7465fbfd562e2a469f90a437ab75"></a>
<a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>findVertex</b> (const T &amp;in) const</td></tr>
<tr class="separator:a8b7b7465fbfd562e2a469f90a437ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00be284ea2be3b3d0f0d2e493b70245b"><td class="memItemLeft" align="right" valign="top"><a id="a00be284ea2be3b3d0f0d2e493b70245b" name="a00be284ea2be3b3d0f0d2e493b70245b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addVertex</b> (const T &amp;in)</td></tr>
<tr class="separator:a00be284ea2be3b3d0f0d2e493b70245b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce9e10080f6f8e882ae52a60bf26192"><td class="memItemLeft" align="right" valign="top"><a id="a8ce9e10080f6f8e882ae52a60bf26192" name="a8ce9e10080f6f8e882ae52a60bf26192"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (const T &amp;sourc, const T &amp;dest, int d, int c, int w)</td></tr>
<tr class="separator:a8ce9e10080f6f8e882ae52a60bf26192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0853eac15cdf0f06d63f4b8a7820ec71"><td class="memItemLeft" align="right" valign="top"><a id="a0853eac15cdf0f06d63f4b8a7820ec71" name="a0853eac15cdf0f06d63f4b8a7820ec71"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumVertex</b> () const</td></tr>
<tr class="separator:a0853eac15cdf0f06d63f4b8a7820ec71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41624b03fcb6bd29e4df574a1ec58541"><td class="memItemLeft" align="right" valign="top"><a id="a41624b03fcb6bd29e4df574a1ec58541" name="a41624b03fcb6bd29e4df574a1ec58541"></a>
std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexSet</b> () const</td></tr>
<tr class="separator:a41624b03fcb6bd29e4df574a1ec58541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740b9faf9f19dd485602f67054154514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a740b9faf9f19dd485602f67054154514">FindPathGivenGroupSize</a> (T st, T ta, int groupSize)</td></tr>
<tr class="separator:a740b9faf9f19dd485602f67054154514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201f3f5fbf9510184e30712879e33429"><td class="memItemLeft" align="right" valign="top"><a id="a201f3f5fbf9510184e30712879e33429" name="a201f3f5fbf9510184e30712879e33429"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberNodes</b> () const</td></tr>
<tr class="separator:a201f3f5fbf9510184e30712879e33429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae512eea4bfdf88516712583a6cb009bd"><td class="memItemLeft" align="right" valign="top"><a id="ae512eea4bfdf88516712583a6cb009bd" name="ae512eea4bfdf88516712583a6cb009bd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberEdges</b> () const</td></tr>
<tr class="separator:ae512eea4bfdf88516712583a6cb009bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2556157dbf5defa8a30cdc0b996136"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ada2556157dbf5defa8a30cdc0b996136">firstAlgorithm</a> (T start, T end)</td></tr>
<tr class="separator:ada2556157dbf5defa8a30cdc0b996136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872df230eb39d51ce5bc9b0ca528c7c0"><td class="memItemLeft" align="right" valign="top"><a id="a872df230eb39d51ce5bc9b0ca528c7c0" name="a872df230eb39d51ce5bc9b0ca528c7c0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>heapComp</b> (const <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v1, const <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v2) const</td></tr>
<tr class="separator:a872df230eb39d51ce5bc9b0ca528c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f471fd8b2b6f0b9df1d9dfad44ecbde"><td class="memItemLeft" align="right" valign="top"><a id="a5f471fd8b2b6f0b9df1d9dfad44ecbde" name="a5f471fd8b2b6f0b9df1d9dfad44ecbde"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNumberNodes</b> (int numberNodes)</td></tr>
<tr class="separator:a5f471fd8b2b6f0b9df1d9dfad44ecbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d2221f4ea01d570bcb05455b7413d2"><td class="memItemLeft" align="right" valign="top"><a id="a13d2221f4ea01d570bcb05455b7413d2" name="a13d2221f4ea01d570bcb05455b7413d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNumberEdges</b> (int numberEdges)</td></tr>
<tr class="separator:a13d2221f4ea01d570bcb05455b7413d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653077e6fdcea071088335aa4bc58a8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a653077e6fdcea071088335aa4bc58a8c">paretoOptimalGroupSizeAndTransportShift</a> (T origin, T target)</td></tr>
<tr class="separator:a653077e6fdcea071088335aa4bc58a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67752a8ed6c82965ab0109769010d33a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a67752a8ed6c82965ab0109769010d33a">recursivePathFinderLimited</a> (T current, T target, int currentCap, int bfsCap, int maxCapEdges)</td></tr>
<tr class="separator:a67752a8ed6c82965ab0109769010d33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3eeca97dce09fe05586c762834c6c7"><td class="memItemLeft" align="right" valign="top"><a id="ada3eeca97dce09fe05586c762834c6c7" name="ada3eeca97dce09fe05586c762834c6c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>allVisitedFalse</b> ()</td></tr>
<tr class="memdesc:ada3eeca97dce09fe05586c762834c6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all nodes from the graph to not visited. <br /></td></tr>
<tr class="separator:ada3eeca97dce09fe05586c762834c6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445a38cf4045797198eae2b818b602de"><td class="memItemLeft" align="right" valign="top"><a id="a445a38cf4045797198eae2b818b602de" name="a445a38cf4045797198eae2b818b602de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dijkstraShortestPath</b> (const T &amp;s)</td></tr>
<tr class="separator:a445a38cf4045797198eae2b818b602de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa033b71894f347b9050e1c547fb48b72"><td class="memItemLeft" align="right" valign="top"><a id="aa033b71894f347b9050e1c547fb48b72" name="aa033b71894f347b9050e1c547fb48b72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unweightedShortestPath</b> (const T &amp;s)</td></tr>
<tr class="separator:aa033b71894f347b9050e1c547fb48b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6769b79beaa76f78fd9c9209833bef"><td class="memItemLeft" align="right" valign="top"><a id="a1d6769b79beaa76f78fd9c9209833bef" name="a1d6769b79beaa76f78fd9c9209833bef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bellmanFordShortestPath</b> (const T &amp;s)</td></tr>
<tr class="separator:a1d6769b79beaa76f78fd9c9209833bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b10f45166faaa19879fca4e73b6f40"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad9b10f45166faaa19879fca4e73b6f40">getPath</a> (const T &amp;origin, const T &amp;dest) const</td></tr>
<tr class="separator:ad9b10f45166faaa19879fca4e73b6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5161f4408bf1ead2b29d19d67fb04ee"><td class="memItemLeft" align="right" valign="top"><a id="ae5161f4408bf1ead2b29d19d67fb04ee" name="ae5161f4408bf1ead2b29d19d67fb04ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>floydWarshallShortestPath</b> ()</td></tr>
<tr class="separator:ae5161f4408bf1ead2b29d19d67fb04ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace531664e93db533d1bcaf532b97348e"><td class="memItemLeft" align="right" valign="top"><a id="ace531664e93db533d1bcaf532b97348e" name="ace531664e93db533d1bcaf532b97348e"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getfloydWarshallPath</b> (const T &amp;origin, const T &amp;dest) const</td></tr>
<tr class="separator:ace531664e93db533d1bcaf532b97348e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a8118f05fc1b0ab2e821618e4a90ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a00a8118f05fc1b0ab2e821618e4a90ac">edmondKarpFlux</a> (T st, T ta)</td></tr>
<tr class="separator:a00a8118f05fc1b0ab2e821618e4a90ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa167310b94b212c2c924f4c68038c7e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html">Graph</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa167310b94b212c2c924f4c68038c7e4">residualGrid</a> ()</td></tr>
<tr class="separator:aa167310b94b212c2c924f4c68038c7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c657f3051db9c08b79239622a495b58"><td class="memItemLeft" align="right" valign="top"><a id="a5c657f3051db9c08b79239622a495b58" name="a5c657f3051db9c08b79239622a495b58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zeroFlux</b> ()</td></tr>
<tr class="memdesc:a5c657f3051db9c08b79239622a495b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets flux of every edge on the graph to zero. <br /></td></tr>
<tr class="separator:a5c657f3051db9c08b79239622a495b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b92cb0e86110b54cdb991a2ac4ae4ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a6b92cb0e86110b54cdb991a2ac4ae4ab">increaseGroupSize</a> (T st, T ta, int inc)</td></tr>
<tr class="separator:a6b92cb0e86110b54cdb991a2ac4ae4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a393ee47d9ff160f1656ef71b890d0"><td class="memItemLeft" align="right" valign="top"><a id="a25a393ee47d9ff160f1656ef71b890d0" name="a25a393ee47d9ff160f1656ef71b890d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>auxTest2_4</b> ()</td></tr>
<tr class="separator:a25a393ee47d9ff160f1656ef71b890d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08eff19f4f9621ca212a0aea7c9a6cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ab08eff19f4f9621ca212a0aea7c9a6cc">topoSort</a> (T st, std::stack&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;stack)</td></tr>
<tr class="separator:ab08eff19f4f9621ca212a0aea7c9a6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242445b60bd1f6c5ee2fe5cf8dd23633"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a242445b60bd1f6c5ee2fe5cf8dd23633">longestPath</a> (T st, T ta)</td></tr>
<tr class="separator:a242445b60bd1f6c5ee2fe5cf8dd23633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5c29368e4760b0b9a81d4967187775"><td class="memItemLeft" align="right" valign="top"><a id="afd5c29368e4760b0b9a81d4967187775" name="afd5c29368e4760b0b9a81d4967187775"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printGraph</b> ()</td></tr>
<tr class="separator:afd5c29368e4760b0b9a81d4967187775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2931de4d06954374ee4724b5817133e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2931de4d06954374ee4724b5817133e1">vertexTime</a> (T st, T ta)</td></tr>
<tr class="separator:a2931de4d06954374ee4724b5817133e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb711e6e2ff8c3f476dfeb0025519ab"><td class="memItemLeft" align="right" valign="top"><a id="acdb711e6e2ff8c3f476dfeb0025519ab" name="acdb711e6e2ff8c3f476dfeb0025519ab"></a>
vector&lt; vector&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>capacityOrEdges</b> (T st, T ta)</td></tr>
<tr class="separator:acdb711e6e2ff8c3f476dfeb0025519ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0fe13c3c612eaf2efab2043f29196b"><td class="memItemLeft" align="right" valign="top"><a id="aeb0fe13c3c612eaf2efab2043f29196b" name="aeb0fe13c3c612eaf2efab2043f29196b"></a>
map&lt; vector&lt; int &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>filterPathsByDominance</b> ()</td></tr>
<tr class="memdesc:aeb0fe13c3c612eaf2efab2043f29196b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters paths on the paths field of the graph to exclude paths that are dominated by others in terms of capacity and path size. <br /></td></tr>
<tr class="separator:aeb0fe13c3c612eaf2efab2043f29196b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9b383b6b265333441e1ca1deceeb994a"><td class="memItemLeft" align="right" valign="top"><a id="a9b383b6b265333441e1ca1deceeb994a" name="a9b383b6b265333441e1ca1deceeb994a"></a>
map&lt; vector&lt; T &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>paths</b></td></tr>
<tr class="separator:a9b383b6b265333441e1ca1deceeb994a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32818c0c4a8a845489fc51c58ed1653"><td class="memItemLeft" align="right" valign="top"><a id="ae32818c0c4a8a845489fc51c58ed1653" name="ae32818c0c4a8a845489fc51c58ed1653"></a>
vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mutatingPath</b></td></tr>
<tr class="separator:ae32818c0c4a8a845489fc51c58ed1653"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a00a8118f05fc1b0ab2e821618e4a90ac" name="a00a8118f05fc1b0ab2e821618e4a90ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a8118f05fc1b0ab2e821618e4a90ac">&#9670;&nbsp;</a></span>edmondKarpFlux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::edmondKarpFlux </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Algorithm to calculate the maximum size of a group that can travel separately Based on the Edmond Karp variant of the Ford Fulkerson method for determining maximum flow Sets appropriate flux for each edge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum group size for the graph </dd></dl>

</div>
</div>
<a id="a740b9faf9f19dd485602f67054154514" name="a740b9faf9f19dd485602f67054154514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740b9faf9f19dd485602f67054154514">&#9670;&nbsp;</a></span>FindPathGivenGroupSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::FindPathGivenGroupSize </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>groupSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Algorithm to calculate the paths for a splittable group of a given size Based on the Edmond Karp variant of the Ford Fulkerson method for determining maximum flow Sets appropriate flux for each edge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
    <tr><td class="paramname">groupSize</td><td>desired group size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map of the paths the group should take </dd></dl>

</div>
</div>
<a id="ada2556157dbf5defa8a30cdc0b996136" name="ada2556157dbf5defa8a30cdc0b996136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2556157dbf5defa8a30cdc0b996136">&#9670;&nbsp;</a></span>firstAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::firstAlgorithm </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prints the caracteristics of all edges in the graph Show origin, destination, flux and capacity Computes the highest capacity path in the graph Works for unseperable groups Based on the algorithm for higest capacity path in the theory slides </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum capacity, in the highest capacity path in the graph </dd></dl>

</div>
</div>
<a id="ad9b10f45166faaa19879fca4e73b6f40" name="ad9b10f45166faaa19879fca4e73b6f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b10f45166faaa19879fca4e73b6f40">&#9670;&nbsp;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getPath </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determines path based on destination and origin Steps back from destination's path to previous vertex until it reaches the origin vertex </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>number associated with Origin <a class="el" href="classVertex.html">Vertex</a> </td></tr>
    <tr><td class="paramname">dest</td><td>number associated with Destination <a class="el" href="classVertex.html">Vertex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of numbers associated with Vertexes in path, in order </dd></dl>

</div>
</div>
<a id="a6b92cb0e86110b54cdb991a2ac4ae4ab" name="a6b92cb0e86110b54cdb991a2ac4ae4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b92cb0e86110b54cdb991a2ac4ae4ab">&#9670;&nbsp;</a></span>increaseGroupSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::increaseGroupSize </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Algorithm to increase group size based on previous paths Based on the Edmond Karp variant of the Ford Fulkerson method for determining maximum flux Sets appropriate flux for each edge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
    <tr><td class="paramname">inc</td><td>amount to increase group size by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>how much the group size was increased by or -1 if it cant be increased by the desired amount </dd></dl>

</div>
</div>
<a id="a242445b60bd1f6c5ee2fe5cf8dd23633" name="a242445b60bd1f6c5ee2fe5cf8dd23633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242445b60bd1f6c5ee2fe5cf8dd23633">&#9670;&nbsp;</a></span>longestPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::longestPath </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the longest path, in duration, between 2 nodes Similar to dijkstra's algorithm for shortest distance paths, using topological sort Should be used after a flux setting algorithm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">ta</td><td>number associated with target vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>longest duration between ta and st nodes </dd></dl>

</div>
</div>
<a id="a653077e6fdcea071088335aa4bc58a8c" name="a653077e6fdcea071088335aa4bc58a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653077e6fdcea071088335aa4bc58a8c">&#9670;&nbsp;</a></span>paretoOptimalGroupSizeAndTransportShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::paretoOptimalGroupSizeAndTransportShift </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the paths field to be all the pareto-optimal solutions (paths) from origin to target nodes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>is the origin node </td></tr>
    <tr><td class="paramname">target</td><td>is the target node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae667eecd89799c645634c0d78a3e98e6" name="ae667eecd89799c645634c0d78a3e98e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae667eecd89799c645634c0d78a3e98e6">&#9670;&nbsp;</a></span>printPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::printPath </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; vector&lt; T &gt;, T &gt;&#160;</td>
          <td class="paramname"><em>printablePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prints all the paths and how many people go through each of them </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">printablePath</td><td>a map of paths, as a vector of nodes T, and number of people that can go through them </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67752a8ed6c82965ab0109769010d33a" name="a67752a8ed6c82965ab0109769010d33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67752a8ed6c82965ab0109769010d33a">&#9670;&nbsp;</a></span>recursivePathFinderLimited()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::recursivePathFinderLimited </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bfsCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCapEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function performs a recursive DFS on the graph looking for all simple paths from origin to target that are within the "pareto-optimal" limitations defined by the paretoOptimal method above. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bfsCap</td><td>the minimum capacity limitation for a valid path to be explored </td></tr>
    <tr><td class="paramname">maxCapEdges</td><td>the maximum path size for exploration worth </td></tr>
    <tr><td class="paramname">currentCap</td><td>keeps the lesser edge capacity found during the path exploration, meaning the capacity that path can transport </td></tr>
    <tr><td class="paramname">current</td><td>the current node from where the path will be searched for </td></tr>
    <tr><td class="paramname">target</td><td>the target node for the path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa167310b94b212c2c924f4c68038c7e4" name="aa167310b94b212c2c924f4c68038c7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa167310b94b212c2c924f4c68038c7e4">&#9670;&nbsp;</a></span>residualGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html">Graph</a>&lt; T &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::residualGrid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a residual grid graph based on the current graph </p><dl class="section return"><dt>Returns</dt><dd>graph object of the residual grid </dd></dl>

</div>
</div>
<a id="ab08eff19f4f9621ca212a0aea7c9a6cc" name="ab08eff19f4f9621ca212a0aea7c9a6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08eff19f4f9621ca212a0aea7c9a6cc">&#9670;&nbsp;</a></span>topoSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::topoSort </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>stack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Inserts nodes on a stack, in topological order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>number associated with start vertex </td></tr>
    <tr><td class="paramname">reference</td><td>to a stack of pointers of nodes, where the nodes will be inserted in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2931de4d06954374ee4724b5817133e1" name="a2931de4d06954374ee4724b5817133e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2931de4d06954374ee4724b5817133e1">&#9670;&nbsp;</a></span>vertexTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::vertexTime </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the earliest and latest arrival at every node Prints every node where people must wait for other people and how long they wait for Dijkstra's algorithm is used to compute earliest arrival LongestPath algorithm is used to compute latest arrival </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Graph_8h_source.html">Graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
